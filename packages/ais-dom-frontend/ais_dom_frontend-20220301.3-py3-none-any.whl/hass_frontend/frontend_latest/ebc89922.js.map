{"version":3,"file":"ebc89922.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsJA;ACxFA;AACA;AAmBA;AACA;;AAoCA;;AAIA;;;;AAKA;;AAEA;AAKA;AASA;;;;AAKA;;AAEA;;AAGA;;AASA;AAeA;AACA;ACxFA;;AAIA;;AAGA;;AAIA;AACA;;;;AAMA;AAlEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./node_modules/@polymer/app-layout/app-header-layout/app-header-layout.js","webpack://home-assistant-frontend/./src/dialogs/config-flow/show-dialog-config-flow.ts","webpack://home-assistant-frontend/./src/panels/lovelace/views/hui-masonry-view.ts"],"sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport '@polymer/iron-flex-layout/iron-flex-layout.js';\n\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\nimport {AppLayoutBehavior} from '../app-layout-behavior/app-layout-behavior.js';\n\n/**\napp-header-layout is a wrapper element that positions an app-header and other\ncontent. This element uses the document scroll by default, but it can also\ndefine its own scrolling region.\n\nUsing the document scroll:\n\n```html\n<app-header-layout>\n  <app-header slot=\"header\" fixed condenses effects=\"waterfall\">\n    <app-toolbar>\n      <div main-title>App name</div>\n    </app-toolbar>\n  </app-header>\n  <div>\n    main content\n  </div>\n</app-header-layout>\n```\n\nUsing an own scrolling region:\n\n```html\n<app-header-layout has-scrolling-region style=\"width: 300px; height: 400px;\">\n  <app-header slot=\"header\" fixed condenses effects=\"waterfall\">\n    <app-toolbar>\n      <div main-title>App name</div>\n    </app-toolbar>\n  </app-header>\n  <div>\n    main content\n  </div>\n</app-header-layout>\n```\n\nAdd the `fullbleed` attribute to app-header-layout to make it fit the size of\nits container:\n\n```html\n<app-header-layout fullbleed>\n ...\n</app-header-layout>\n```\n\n@element app-header-layout\n@demo app-header-layout/demo/simple.html Simple Demo\n@demo app-header-layout/demo/scrolling-region.html Scrolling Region\n@demo app-header-layout/demo/music.html Music Demo\n@demo app-header-layout/demo/footer.html Footer Demo\n*/\nPolymer({\n  /** @override */\n  _template: html`\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      #wrapper ::slotted([slot=header]) {\n        @apply --layout-fixed-top;\n        z-index: 1;\n      }\n\n      #wrapper.initializing ::slotted([slot=header]) {\n        position: relative;\n      }\n\n      :host([has-scrolling-region]) {\n        height: 100%;\n      }\n\n      :host([has-scrolling-region]) #wrapper ::slotted([slot=header]) {\n        position: absolute;\n      }\n\n      :host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]) {\n        position: relative;\n      }\n\n      :host([has-scrolling-region]) #wrapper #contentContainer {\n        @apply --layout-fit;\n        overflow-y: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n        position: relative;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-vertical;\n        @apply --layout-fit;\n      }\n\n      :host([fullbleed]) #wrapper,\n      :host([fullbleed]) #wrapper #contentContainer {\n        @apply --layout-vertical;\n        @apply --layout-flex;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n      }\n\n      @media print {\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          overflow-y: visible;\n        }\n      }\n\n    </style>\n\n    <div id=\"wrapper\" class=\"initializing\">\n      <slot id=\"headerSlot\" name=\"header\"></slot>\n\n      <div id=\"contentContainer\">\n        <slot></slot>\n      </div>\n    </div>\n`,\n\n  is: 'app-header-layout',\n  behaviors: [AppLayoutBehavior],\n\n  properties: {\n    /**\n     * If true, the current element will have its own scrolling region.\n     * Otherwise, it will use the document scroll to control the header.\n     */\n    hasScrollingRegion: {type: Boolean, value: false, reflectToAttribute: true}\n  },\n\n  observers: ['resetLayout(isAttached, hasScrollingRegion)'],\n\n  /**\n   * A reference to the app-header element.\n   *\n   * @property header\n   */\n  get header() {\n    return dom(this.$.headerSlot).getDistributedNodes()[0];\n  },\n\n  _updateLayoutStates: function() {\n    var header = this.header;\n    if (!this.isAttached || !header) {\n      return;\n    }\n    // Remove the initializing class, which staticly positions the header and\n    // the content until the height of the header can be read.\n    this.$.wrapper.classList.remove('initializing');\n    // Update scroll target.\n    header.scrollTarget = this.hasScrollingRegion ?\n        this.$.contentContainer :\n        this.ownerDocument.documentElement;\n    // Get header height here so that style reads are batched together before\n    // style writes (i.e. getBoundingClientRect() below).\n    var headerHeight = header.offsetHeight;\n    // Update the header position.\n    if (!this.hasScrollingRegion) {\n      requestAnimationFrame(function() {\n        var rect = this.getBoundingClientRect();\n        var rightOffset = document.documentElement.clientWidth - rect.right;\n        header.style.left = rect.left + 'px';\n        header.style.right = rightOffset + 'px';\n      }.bind(this));\n    } else {\n      header.style.left = '';\n      header.style.right = '';\n    }\n    // Update the content container position.\n    var containerStyle = this.$.contentContainer.style;\n    if (header.fixed && !header.condenses && this.hasScrollingRegion) {\n      // If the header size does not change and we're using a scrolling region,\n      // exclude the header area from the scrolling region so that the header\n      // doesn't overlap the scrollbar.\n      containerStyle.marginTop = headerHeight + 'px';\n      containerStyle.paddingTop = '';\n    } else {\n      containerStyle.paddingTop = headerHeight + 'px';\n      containerStyle.marginTop = '';\n    }\n  }\n});\n","import { html } from \"lit\";\nimport { caseInsensitiveStringCompare } from \"../../common/string/compare\";\nimport {\n  createConfigFlow,\n  deleteConfigFlow,\n  fetchConfigFlow,\n  getConfigFlowHandlers,\n  handleConfigFlowStep,\n} from \"../../data/config_flow\";\nimport { domainToName } from \"../../data/integration\";\nimport {\n  DataEntryFlowDialogParams,\n  loadDataEntryFlowDialog,\n  showFlowDialog,\n} from \"./show-dialog-data-entry-flow\";\n\nexport const loadConfigFlowDialog = loadDataEntryFlowDialog;\n\nexport const showConfigFlowDialog = (\n  element: HTMLElement,\n  dialogParams: Omit<DataEntryFlowDialogParams, \"flowConfig\">\n): void =>\n  showFlowDialog(element, dialogParams, {\n    loadDevicesAndAreas: true,\n    getFlowHandlers: async (hass) => {\n      const [handlers] = await Promise.all([\n        getConfigFlowHandlers(hass),\n        hass.loadBackendTranslation(\"title\", undefined, true),\n      ]);\n\n      return handlers.sort((handlerA, handlerB) =>\n        caseInsensitiveStringCompare(\n          domainToName(hass.localize, handlerA),\n          domainToName(hass.localize, handlerB)\n        )\n      );\n    },\n    createFlow: async (hass, handler) => {\n      const [step] = await Promise.all([\n        createConfigFlow(hass, handler),\n        hass.loadBackendTranslation(\"config\", handler),\n        // Used as fallback if no header defined for step\n        hass.loadBackendTranslation(\"title\", handler),\n      ]);\n      return step;\n    },\n    fetchFlow: async (hass, flowId) => {\n      const step = await fetchConfigFlow(hass, flowId);\n      await hass.loadBackendTranslation(\"config\", step.handler);\n      return step;\n    },\n    handleFlowStep: handleConfigFlowStep,\n    deleteFlow: deleteConfigFlow,\n\n    renderAbortDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.handler}.config.abort.${step.reason}`,\n        step.description_placeholders\n      );\n\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderShowFormStepHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) || hass.localize(`component.${step.handler}.title`)\n      );\n    },\n\n    renderShowFormStepDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.handler}.config.step.${step.step_id}.description`,\n        step.description_placeholders\n      );\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderShowFormStepFieldLabel(hass, step, field) {\n      return hass.localize(\n        `component.${step.handler}.config.step.${step.step_id}.data.${field.name}`\n      );\n    },\n\n    renderShowFormStepFieldError(hass, step, error) {\n      return hass.localize(\n        `component.${step.handler}.config.error.${error}`,\n        step.description_placeholders\n      );\n    },\n\n    renderExternalStepHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) ||\n        hass.localize(\n          \"ui.panel.config.integrations.config_flow.external_step.open_site\"\n        )\n      );\n    },\n\n    renderExternalStepDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.handler}.config.${step.step_id}.description`,\n        step.description_placeholders\n      );\n\n      return html`\n        <p>\n          ${hass.localize(\n            \"ui.panel.config.integrations.config_flow.external_step.description\"\n          )}\n        </p>\n        ${description\n          ? html`\n              <ha-markdown\n                allowsvg\n                breaks\n                .content=${description}\n              ></ha-markdown>\n            `\n          : \"\"}\n      `;\n    },\n\n    renderCreateEntryDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.handler}.config.create_entry.${\n          step.description || \"default\"\n        }`,\n        step.description_placeholders\n      );\n\n      return html`\n        ${description\n          ? html`\n              <ha-markdown\n                allowsvg\n                breaks\n                .content=${description}\n              ></ha-markdown>\n            `\n          : \"\"}\n        <p>\n          ${hass.localize(\n            \"ui.panel.config.integrations.config_flow.created_config\",\n            \"name\",\n            step.title\n          )}\n        </p>\n      `;\n    },\n\n    renderShowFormProgressHeader(hass, step) {\n      return (\n        hass.localize(\n          `component.${step.handler}.config.step.${step.step_id}.title`\n        ) || hass.localize(`component.${step.handler}.title`)\n      );\n    },\n\n    renderShowFormProgressDescription(hass, step) {\n      const description = hass.localize(\n        `component.${step.handler}.config.progress.${step.progress_action}`,\n        step.description_placeholders\n      );\n      return description\n        ? html`\n            <ha-markdown allowsvg breaks .content=${description}></ha-markdown>\n          `\n        : \"\";\n    },\n\n    renderLoadingDescription(hass, reason, handler, step) {\n      if (![\"loading_flow\", \"loading_step\"].includes(reason)) {\n        return \"\";\n      }\n      const domain = step?.handler || handler;\n      return hass.localize(\n        `ui.panel.config.integrations.config_flow.loading.${reason}`,\n        {\n          integration: domain\n            ? domainToName(hass.localize, domain)\n            : // when we are continuing a config flow, we only know the ID and not the domain\n              hass.localize(\n                \"ui.panel.config.integrations.config_flow.loading.fallback_title\"\n              ),\n        }\n      );\n    },\n  });\n","import { mdiPlus } from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { fireEvent } from \"../../../common/dom/fire_event\";\nimport { computeRTL } from \"../../../common/util/compute_rtl\";\nimport { nextRender } from \"../../../common/util/render-status\";\nimport \"../../../components/entity/ha-state-label-badge\";\nimport \"../../../components/ha-svg-icon\";\nimport type {\n  LovelaceViewConfig,\n  LovelaceViewElement,\n} from \"../../../data/lovelace\";\nimport type { HomeAssistant } from \"../../../types\";\nimport type { HuiErrorCard } from \"../cards/hui-error-card\";\nimport { computeCardSize } from \"../common/compute-card-size\";\nimport type { Lovelace, LovelaceBadge, LovelaceCard } from \"../types\";\n\n// Find column with < 5 size, else smallest column\nconst getColumnIndex = (columnSizes: number[], size: number) => {\n  let minIndex = 0;\n  for (let i = 0; i < columnSizes.length; i++) {\n    if (columnSizes[i] < 5) {\n      minIndex = i;\n      break;\n    }\n    if (columnSizes[i] < columnSizes[minIndex]) {\n      minIndex = i;\n    }\n  }\n\n  columnSizes[minIndex] += size;\n\n  return minIndex;\n};\n\nexport class MasonryView extends LitElement implements LovelaceViewElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public lovelace?: Lovelace;\n\n  @property({ type: Boolean }) public narrow!: boolean;\n\n  @property({ type: Number }) public index?: number;\n\n  @property({ type: Boolean }) public isStrategy = false;\n\n  @property({ attribute: false }) public cards: Array<\n    LovelaceCard | HuiErrorCard\n  > = [];\n\n  @property({ attribute: false }) public badges: LovelaceBadge[] = [];\n\n  @state() private _columns?: number;\n\n  private _createColumnsIteration = 0;\n\n  private _mqls?: MediaQueryList[];\n\n  private _mqlListenerRef?: () => void;\n\n  public constructor() {\n    super();\n    this.addEventListener(\"iron-resize\", (ev: Event) => ev.stopPropagation());\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._initMqls();\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._mqls?.forEach((mql) => {\n      mql.removeListener(this._mqlListenerRef!);\n    });\n    this._mqlListenerRef = undefined;\n    this._mqls = undefined;\n  }\n\n  public setConfig(_config: LovelaceViewConfig): void {}\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.badges.length > 0\n        ? html` <div class=\"badges\">${this.badges}</div>`\n        : \"\"}\n      <div id=\"columns\"></div>\n      ${this.lovelace?.editMode\n        ? html`\n            <ha-fab\n              .label=${this.hass!.localize(\n                \"ui.panel.lovelace.editor.edit_card.add\"\n              )}\n              extended\n              @click=${this._addCard}\n              class=${classMap({\n                rtl: computeRTL(this.hass!),\n              })}\n            >\n              <ha-svg-icon slot=\"icon\" .path=${mdiPlus}></ha-svg-icon>\n            </ha-fab>\n          `\n        : \"\"}\n    `;\n  }\n\n  private _initMqls() {\n    this._mqls = [300, 600, 900, 1200].map((width) => {\n      const mql = window.matchMedia(`(min-width: ${width}px)`);\n      if (!this._mqlListenerRef) {\n        this._mqlListenerRef = this._updateColumns.bind(this);\n      }\n      mql.addListener(this._mqlListenerRef);\n      return mql;\n    });\n  }\n\n  private get mqls(): MediaQueryList[] {\n    if (!this._mqls) {\n      this._initMqls();\n    }\n    return this._mqls!;\n  }\n\n  public willUpdate(changedProperties: PropertyValues) {\n    super.willUpdate(changedProperties);\n\n    if (this.lovelace?.editMode) {\n      import(\"./default-view-editable\");\n    }\n\n    if (changedProperties.has(\"hass\")) {\n      const oldHass = changedProperties.get(\"hass\") as\n        | HomeAssistant\n        | undefined;\n\n      if (this.hass!.dockedSidebar !== oldHass?.dockedSidebar) {\n        this._updateColumns();\n        return;\n      }\n    }\n\n    if (changedProperties.has(\"narrow\")) {\n      this._updateColumns();\n      return;\n    }\n\n    const oldLovelace = changedProperties.get(\"lovelace\") as\n      | Lovelace\n      | undefined;\n\n    if (\n      changedProperties.has(\"cards\") ||\n      (changedProperties.has(\"lovelace\") &&\n        oldLovelace &&\n        (oldLovelace.config !== this.lovelace!.config ||\n          oldLovelace.editMode !== this.lovelace!.editMode))\n    ) {\n      this._createColumns();\n    }\n  }\n\n  private _addCard(): void {\n    fireEvent(this, \"ll-create-card\");\n  }\n\n  private _createRootElement(columns: HTMLDivElement[]) {\n    const root = this.shadowRoot!.getElementById(\"columns\") as HTMLDivElement;\n\n    // Remove old columns\n    while (root.lastChild) {\n      root.removeChild(root.lastChild);\n    }\n\n    columns.forEach((column) => root.appendChild(column));\n  }\n\n  private async _createColumns() {\n    if (!this._columns) {\n      return;\n    }\n\n    this._createColumnsIteration++;\n    const iteration = this._createColumnsIteration;\n\n    // Track the total height of cards in a columns\n    const columnSizes: number[] = [];\n    const columnElements: HTMLDivElement[] = [];\n    // Add columns to DOM, limit number of columns to the number of cards\n    for (let i = 0; i < Math.min(this._columns, this.cards.length); i++) {\n      const columnEl = document.createElement(\"div\");\n      columnEl.classList.add(\"column\");\n      columnSizes.push(0);\n      columnElements.push(columnEl);\n    }\n\n    if (!this.hasUpdated) {\n      this.updateComplete.then(() => {\n        this._createRootElement(columnElements);\n      });\n    } else {\n      this._createRootElement(columnElements);\n    }\n\n    let tillNextRender: Promise<unknown> | undefined;\n    let start: Date | undefined;\n\n    // Calculate the size of every card and determine in what column it should go\n    for (const [index, el] of this.cards.entries()) {\n      if (tillNextRender === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        tillNextRender = nextRender().then(() => {\n          tillNextRender = undefined;\n          start = undefined;\n        });\n      }\n\n      let waitProm: Promise<unknown> | undefined;\n\n      // We should work for max 16ms (60fps) before allowing a frame to render\n      if (start === undefined) {\n        // Save the time we start for this frame, no need to wait yet\n        start = new Date();\n      } else if (new Date().getTime() - start.getTime() > 16) {\n        // We are working too long, we will prevent a render, wait to allow for a render\n        waitProm = tillNextRender;\n      }\n\n      const cardSizeProm = computeCardSize(el);\n      // @ts-ignore\n      // eslint-disable-next-line no-await-in-loop\n      const [cardSize] = await Promise.all([cardSizeProm, waitProm]);\n\n      if (iteration !== this._createColumnsIteration) {\n        // An other create columns is started, abort this one\n        return;\n      }\n      // Calculate in wich column the card should go based on the size and the cards already in there\n      this._addCardToColumn(\n        columnElements[getColumnIndex(columnSizes, cardSize as number)],\n        index,\n        this.lovelace!.editMode\n      );\n    }\n\n    // Remove empty columns\n    columnElements.forEach((column) => {\n      if (!column.lastChild) {\n        column.parentElement!.removeChild(column);\n      }\n    });\n  }\n\n  private _addCardToColumn(columnEl, index, editMode) {\n    const card: LovelaceCard = this.cards[index];\n    if (!editMode || this.isStrategy) {\n      card.editMode = false;\n      columnEl.appendChild(card);\n    } else {\n      const wrapper = document.createElement(\"hui-card-options\");\n      wrapper.hass = this.hass;\n      wrapper.lovelace = this.lovelace;\n      wrapper.path = [this.index!, index];\n      card.editMode = true;\n      wrapper.appendChild(card);\n      columnEl.appendChild(wrapper);\n    }\n  }\n\n  private _updateColumns() {\n    const matchColumns = this.mqls.reduce(\n      (cols, mql) => cols + Number(mql.matches),\n      0\n    );\n    // Do -1 column if the menu is docked and open\n    const newColumns = Math.max(\n      1,\n      matchColumns -\n        Number(!this.narrow && this.hass!.dockedSidebar === \"docked\")\n    );\n    if (newColumns === this._columns) {\n      return;\n    }\n    this._columns = newColumns;\n    this._createColumns();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        padding-top: 4px;\n        height: 100%;\n        box-sizing: border-box;\n      }\n\n      .badges {\n        margin: 8px 16px;\n        font-size: 85%;\n        text-align: center;\n      }\n\n      #columns {\n        display: flex;\n        flex-direction: row;\n        justify-content: center;\n        margin-left: 4px;\n        margin-right: 4px;\n      }\n\n      .column {\n        flex: 1 0 0;\n        max-width: 500px;\n        min-width: 0;\n      }\n\n      .column > * {\n        display: block;\n        margin: var(--masonry-view-card-margin, 4px 4px 8px);\n      }\n\n      ha-fab {\n        position: sticky;\n        float: right;\n        right: calc(16px + env(safe-area-inset-right));\n        bottom: calc(16px + env(safe-area-inset-bottom));\n        z-index: 1;\n      }\n\n      ha-fab.rtl {\n        float: left;\n        right: auto;\n        left: calc(16px + env(safe-area-inset-left));\n      }\n\n      @media (max-width: 500px) {\n        .column > * {\n          margin-left: 0;\n          margin-right: 0;\n        }\n      }\n\n      @media (max-width: 599px) {\n        .column {\n          max-width: 600px;\n        }\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-masonry-view\": MasonryView;\n  }\n}\n\ncustomElements.define(\"hui-masonry-view\", MasonryView);\n"],"names":[],"sourceRoot":""}