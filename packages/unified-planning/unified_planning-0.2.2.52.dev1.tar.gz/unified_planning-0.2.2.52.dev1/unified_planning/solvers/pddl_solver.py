# Copyright 2021 AIPlan4EU project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""This module defines an interface for a generic PDDL planner."""


import select
import tempfile
import os
import re
import subprocess
import time
import unified_planning as up
import unified_planning.solvers as solvers
from unified_planning.shortcuts import *
from unified_planning.solvers.results import PlanGenerationResult
from unified_planning.io.pddl_writer import PDDLWriter
from unified_planning.exceptions import UPException
from typing import IO, Any, Callable, Optional, List


class PDDLSolver(solvers.solver.Solver):
    """
    This class is the interface of a generic PDDL solver
    that can be invocated through a subprocess call.
    """

    def __init__(self, needs_requirements=True):
        solvers.solver.Solver.__init__(self)
        self._needs_requirements = needs_requirements

    @staticmethod
    def is_oneshot_planner() -> bool:
        return True

    def _get_cmd(self, domain_filename: str, problem_filename: str, plan_filename: str) -> List[str]:
        '''Takes in input two filenames where the problem's domain and problem are written, a
        filename where to write the plan and returns a list of command to run the solver on the
        problem and write the plan on the file called plan_filename.'''
        raise NotImplementedError

    def _plan_from_file(self, problem: 'up.model.Problem', plan_filename: str) -> 'up.plan.Plan':
        '''Takes a problem and a filename and returns the plan parsed from the file.'''
        actions = []
        with open(plan_filename) as plan:
            for line in plan.readlines():
                if re.match(r'^\s*(;.*)?$', line):
                    continue
                res = re.match(r'^\s*\(\s*([\w?-]+)((\s+[\w?-]+)*)\s*\)\s*$', line)
                if res:
                    action = problem.action(res.group(1))
                    parameters = []
                    for p in res.group(2).split():
                        parameters.append(ObjectExp(problem.object(p)))
                    actions.append(up.plan.ActionInstance(action, tuple(parameters)))
                else:
                    raise UPException('Error parsing plan generated by ' + self.__class__.__name__)
        return up.plan.SequentialPlan(actions)

    def solve(self, problem: 'up.model.Problem',
                callback: Optional[Callable[['up.solvers.results.PlanGenerationResult'], None]] = None,
                timeout: Optional[float] = None,
                output_stream: Optional[IO[str]] = None) -> 'up.solvers.results.PlanGenerationResult':
        w = PDDLWriter(problem, self._needs_requirements)
        plan = None
        logs: List['up.solvers.results.LogMessage'] = []
        with tempfile.TemporaryDirectory() as tempdir:
            domanin_filename = os.path.join(tempdir, 'domain.pddl')
            problem_filename = os.path.join(tempdir, 'problem.pddl')
            plan_filename = os.path.join(tempdir, 'plan.txt')
            w.write_domain(domanin_filename)
            w.write_problem(problem_filename)
            cmd = self._get_cmd(domanin_filename, problem_filename, plan_filename)
            proc_out: List[str] = []
            proc_err: List[str] = []

            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            timeout_occurred = False
            if output_stream is None:
                try:
                    out_err_bytes = proc.communicate(timeout=timeout)
                    proc_out, proc_err = [out_err_bytes[0].decode()], [out_err_bytes[1].decode()]
                except subprocess.TimeoutExpired:
                    timeout_occurred = True
            else: #output_stream is not None
                start_time = time.time()
                last_red_out, last_red_err = 0, 0 #Variables needed for the correct loop exit
                readable_streams: List[Any] = []
                # Exit loop condition: Both stream have nothing left to read or the planner is out of time
                while not timeout_occurred and (len(readable_streams) != 2 or last_red_out != 0 or last_red_err != 0):
                    readable_streams, _, _ = select.select([proc.stdout, proc.stderr], [], [], 1.0) #1.0 is the timeout
                    if timeout is not None and time.time() - start_time >= timeout: # Check if the planner is out of time.
                        proc.kill()
                        timeout_occurred = True
                    for readable_stream in readable_streams:
                        out_in_bytes = readable_stream.read()
                        out_str = out_in_bytes.decode()
                        output_stream.write(out_str)
                        if readable_stream == proc.stdout:
                            proc_out.append(out_str)
                            last_red_out = len(out_in_bytes)
                        else:
                            proc_err.append(out_str)
                            last_red_err = len(out_in_bytes)
                proc.wait()
            logs.append(up.solvers.results.LogMessage(up.solvers.results.INFO, ''.join(proc_out)))
            logs.append(up.solvers.results.LogMessage(up.solvers.results.ERROR, ''.join(proc_err)))
            if os.path.isfile(plan_filename):
                plan = self._plan_from_file(problem, plan_filename)
            if timeout_occurred and proc.returncode != 0: # Also check returncode, in case the planner did finish normally
                return PlanGenerationResult(up.solvers.results.TIMEOUT, plan=plan, log_messages=logs, planner_name=self.name()) #The plan could be "plan" and not None, to see if a plan was found during the timeout
        status: int = self._result_status(problem, plan)
        return PlanGenerationResult(status, plan, log_messages=logs, planner_name=self.name())

    def _result_status(self, problem: 'up.model.Problem', plan: Optional['up.plan.Plan']) -> int:
        '''Takes a problem and a plan and returns the status that represents this plan.
        The possible status with their interpretation can be found in the up.plan file.'''
        raise NotImplementedError

    def destroy(self):
        pass
