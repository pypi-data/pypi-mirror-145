import copy
from typing import Any
from typing import Dict
from typing import List

__contracts__ = ["resource"]


async def present(
    hub,
    ctx,
    name: str,
    resource_id: str = None,
    description: str = "",
    key_usage: str = "ENCRYPT_DECRYPT",
    key_spec: str = "SYMMETRIC_DEFAULT",
    key_state: str = "Enabled",
    origin: str = "AWS_KMS",
    multi_region: bool = False,
    policy: str = None,
    bypass_policy_lockout_safety_check: bool = False,
    tags: List = None,
) -> Dict[str, Any]:
    r"""
    **Autogenerated function**

    Create or update AWS kms key.

    Update limitations:
    Tags can be updated on the key using tag_resource and untag_resource.
    Key state can be updated: disable / enable key.
    Policy can be updated, but cannot be cleared once set.

    Args:
        hub:
        ctx:
        name(str): A name of the kms key
        resource_id(str, Optional): ID to identify the resource, key arn
        description(str, Optional): description of the key
        key_usage(str, Default: 'ENCRYPT_DECRYPT'): optional values: 'SIGN_VERIFY'|'ENCRYPT_DECRYPT'
        key_spec(str, Default: "SYMMETRIC_DEFAULT"): optional values: 'RSA_2048'|'RSA_3072'|
            'RSA_4096'|'ECC_NIST_P256'|'ECC_NIST_P384'|'ECC_NIST_P521'|'ECC_SECG_P256K1'|'SYMMETRIC_DEFAULT'
        key_state(str: Default: Enabled): by default key is enabled. Use 'Disabled' to disable the key.
        origin(str, Default: "AWS_KMS"): optional values: 'AWS_KMS'|'EXTERNAL'|'AWS_CLOUDHSM'
        multi_region(bool, Default: False):
        policy(str, Optional): a default policy is created for each key
        bypass_policy_lockout_safety_check(bool, Default = False): bypass policy safety check, should be true when
            policy is specified or key creation fails with this error:
            "The new key policy will not allow you to update the key policy in the future.
            This field is not returned by 'describe'.
        tags(List, Optional): List of TagKey and TagValue pairs

    Request Syntax:
        [key-resource-id]:
          aws.kms.key.present:
          - resource_id: 'string'
          - description: 'string'
          - key_state: 'string'
          - key_usage: 'string'
          - key_spec: 'string'
          - multi_region: 'boolean'
          - bypass_policy_lockout_safety_check: 'boolean'
          - policy: 'string'
          - tags:
            - TagKey: 'string'
              TagValue: 'string'

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            new-key:
                aws.kms.key.present:
                    - key_state: Enabled
                    - description: key-with-policy-and-tags
                    - key_usage: ENCRYPT_DECRYPT
                    - key_spec: SYMMETRIC_DEFAULT
                    - multi_region: false
                    - bypass_policy_lockout_safety_check: true
                    - policy: "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"EnableIAMUserPermissions\",\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::537227425989:root\"},\"Action\":[\"kms:Create*\",\"kms:Describe*\",\"kms:Enable*\"],\"Resource\":\"*\"}]}"
                    - tags:
                        - TagKey: test-key
                          TagValue: test-value
                        - TagKey: test-key-1
                          TagValue: test-key-1
    """

    result = dict(comment=(), old_state=None, new_state=None, name=name, result=True)

    before = None
    if resource_id is not None:
        before = await hub.exec.boto3.client.kms.describe_key(ctx, KeyId=resource_id)

    policy = hub.tool.aws.state_comparison_utils.standardise_json(policy)

    if before and before["result"]:
        result[
            "old_state"
        ] = await hub.tool.aws.kms.conversion_utils.convert_raw_key_to_present(
            ctx, raw_resource=before["ret"]["KeyMetadata"]
        )
        result["comment"] = (f"aws.kms.key '{name}' already exists.",)
        # Used for 'test'
        plan_state = copy.deepcopy(result["old_state"])

        # Update key tags if tags are specified
        if (
            tags is not None
            and not hub.tool.aws.state_comparison_utils.are_lists_identical(
                tags, result["old_state"].get("tags", None)
            )
        ):
            hub.log.debug(f"aws.kms.key '{name}' tags update")
            # For tag operations key_id is used and not resource_id
            update_ret = await hub.exec.aws.kms.key.update_key_tags(
                ctx=ctx,
                key_id=resource_id,
                old_tags=result["old_state"].get("tags", []),
                new_tags=tags,
            )

            result["result"] = update_ret["result"]
            result["comment"] = result["comment"] + update_ret["comment"]
            if not result["result"]:
                return result

            plan_state["tags"] = update_ret["ret"].get("tags")

        # Enable/Disable key
        # No updates for key_state "PendingDeletion", which means the key is scheduled to be deleted.
        old_state = result["old_state"].get("key_state", "")
        if key_state != old_state:
            if ctx.get("test", False):
                result["comment"] = result["comment"] + (
                    f"Would update state on aws.kms.key '{name}'.",
                )
                plan_state["key_state"] = key_state
            else:
                update_ret = None
                if old_state == "Enabled" and key_state == "Disabled":
                    update_ret = await hub.exec.boto3.client.kms.disable_key(
                        ctx, KeyId=result["old_state"]["resource_id"]
                    )
                elif old_state == "Disabled" and key_state == "Enabled":
                    update_ret = await hub.exec.boto3.client.kms.enable_key(
                        ctx, KeyId=result["old_state"]["resource_id"]
                    )

                if update_ret:
                    hub.log.debug(
                        f"Updated the state of aws.kms.key '{name}' to '{key_state}'."
                    )
                    result["comment"] = result["comment"] + (
                        f"Updated aws.kms.key '{name}' state to '{key_state}'.",
                    )
                else:
                    hub.log.warning(
                        f"Failed to update the state of aws.kms.key '{name}' to '{key_state}'. {update_ret['comment']} "
                    )
                    result["result"] = update_ret["result"]
                    result["comment"] = result["comment"] + update_ret["comment"]
                    return result

        # Update policy if needed
        if policy:
            if not hub.tool.aws.state_comparison_utils.is_json_identical(
                result["old_state"].get("policy"), policy
            ):
                if ctx.get("test", False):
                    result["comment"] = result["comment"] + (
                        f"Would update policy of aws.kms.key '{name}'.",
                    )
                    plan_state["policy"] = policy
                else:
                    update_ret = await hub.exec.boto3.client.kms.put_key_policy(
                        ctx,
                        KeyId=result["old_state"]["resource_id"],
                        Policy=policy,
                        PolicyName="default",
                    )

                    if update_ret["result"]:
                        result["comment"] = result["comment"] + (
                            f"Updated aws.kms.key '{name}' policy.",
                        )
                    else:
                        hub.log.warning(
                            f"Failed to update the policy of aws.kms.key '{name}': {update_ret['comment']}"
                        )
                        result["result"] = update_ret["result"]
                        result["comment"] = result["comment"] + update_ret["comment"]
                        return result

        # Update description if needed
        if description and description != result["old_state"].get("description"):
            if ctx.get("test", False):
                result["comment"] = result["comment"] + (
                    f"Would update description of aws.kms.key '{name}'.",
                )
                plan_state["description"] = description
            else:
                update_ret = await hub.exec.boto3.client.kms.update_key_description(
                    ctx,
                    KeyId=result["old_state"]["resource_id"],
                    Description=description,
                )

                if update_ret["result"]:
                    result["comment"] = result["comment"] + (
                        f"Updated aws.kms.key '{name}' description.",
                    )
                else:
                    hub.log.warning(
                        f"Failed to update the description of aws.kms.key '{name}': {update_ret['comment']}"
                    )
                    result["result"] = update_ret["result"]
                    result["comment"] = result["comment"] + update_ret["comment"]
                    return result
    else:
        try:
            if ctx.get("test", False):
                result["new_state"] = hub.tool.aws.test_state_utils.generate_test_state(
                    enforced_state={},
                    desired_state={
                        "name": name,
                        "resource_id": f"key-{name}-resource_id",
                        "arn": f"key-{name}-arn",
                        "description": description,
                        "key_usage": key_usage,
                        "key_spec": key_spec,
                        "origin": origin,
                        "multi_region": multi_region,
                        "policy": policy,
                        "bypass_policy_lockout_safety_check": bypass_policy_lockout_safety_check,
                        "tags": tags,
                    },
                )
                result["comment"] = (f"Would create aws.kms.key {name}",)
                return result

            ret = await hub.exec.boto3.client.kms.create_key(
                ctx,
                Description=description,
                KeyUsage=key_usage,
                KeySpec=key_spec,
                Origin=origin,
                MultiRegion=multi_region,
                Policy=policy,
                BypassPolicyLockoutSafetyCheck=bypass_policy_lockout_safety_check,
                Tags=tags,
            )

            result["result"] = ret["result"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            resource_id = ret["ret"]["KeyMetadata"]["KeyId"]
            result["comment"] = (
                f"Created aws.kms.key '{name}' with description '{description}'.",
            )
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"
            result["result"] = False

    if ctx.get("test", False):
        result["new_state"] = plan_state
    else:
        try:
            after = await hub.exec.boto3.client.kms.describe_key(ctx, KeyId=resource_id)
            if after.get("ret"):
                result[
                    "new_state"
                ] = await hub.tool.aws.kms.conversion_utils.convert_raw_key_to_present(
                    ctx, raw_resource=after["ret"].get("KeyMetadata", None)
                )
        except Exception as e:
            result["comment"] = result["comment"] + (str(e),)
            result["result"] = False

    return result


async def absent(
    hub, ctx, name: str, resource_id: str = None, pending_window_in_days: int = 7
) -> Dict[str, Any]:
    r"""
    **Autogenerated function**

    Key cannot be immediately deleted but can be scheduled to be deleted.
    Also key can be disabled using the present function with key_state = 'Disabled'.
    Args:
        hub:
        ctx:
        name(Text): Name of the key.
        resource_id(Text, Optional): ID of the key.
        pending_window_in_days(int, Optional, Default: 7 days): -- how many days before key is deleted.
    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws.kms.key.absent:
                - resource_id: value
                - name: value
    """

    result = dict(comment=(), old_state=None, new_state=None, name=name, result=True)

    before = await hub.exec.boto3.client.kms.describe_key(ctx, KeyId=resource_id)

    if not before:
        result["comment"] = (f"aws.kms.key '{name}' already absent",)
        return result
    else:
        result[
            "old_state"
        ] = await hub.tool.aws.kms.conversion_utils.convert_raw_key_to_present(
            ctx, raw_resource=before["ret"]["KeyMetadata"]
        )

        if before["ret"]["KeyMetadata"].get("DeletionDate", None):
            result["comment"] = (
                f"aws.kms.key '{name}' already scheduled to be deleted",
            )
            return result

        if ctx.get("test", False):
            result["comment"] = (
                f"Would schedule deletion of aws.kms.key {resource_id}",
            )
            return result

        try:
            # Minimum deletion schedule 7 days (from 7 - 30)
            ret = await hub.exec.boto3.client.kms.schedule_key_deletion(
                ctx,
                KeyId=resource_id,
                PendingWindowInDays=pending_window_in_days,
            )
            result["result"] = ret["result"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                result["result"] = False
                return result
            result["comment"] = (
                f"aws.kms.key '{name}' is scheduled for deletion in {pending_window_in_days} days",
            )
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = (f"{e.__class__.__name__}: {e}",)

    try:
        after = await hub.exec.boto3.client.kms.describe_key(
            ctx, KeyId=(resource_id if resource_id else name)
        )
        if after.get("ret"):
            result[
                "new_state"
            ] = await hub.tool.aws.kms.conversion_utils.convert_raw_key_to_present(
                ctx, raw_resource=after["ret"]["KeyMetadata"]
            )
    except Exception as e:
        result["comment"] = result["comment"] + (str(e),)
        result["result"] = False
    return result


async def describe(hub, ctx) -> Dict[str, Dict[str, Any]]:
    r"""
    Describe the resource in a way that can be recreated/managed with the corresponding "present" function


    Gets a list of keys in the caller's Amazon Web Services account and region. For more information about
    keys, see Createkey. By default, the Listkeys operation returns all keys in the account and region.
    To get only the keys associated with a particular KMS key, use the KeyId parameter. The Listkeys response
    can include keys that you created and associated with your customer managed keys, and keys that Amazon Web
    Services created and associated with Amazon Web Services managed keys in your account. You can recognize Amazon
    Web Services keys because their names have the format aws/<service-name>, such as aws/dynamodb. The response
    might also include keys that have no TargetKeyId field. These are predefined keys that Amazon Web Services
    has created but has not yet associated with a KMS key. keys that Amazon Web Services creates in your account,
    including predefined keys, do not count against your KMS keys quota.  Cross-account use: No. Listkeys
    does not return keys in other Amazon Web Services accounts.  Required permissions: kms:Listkeys (IAM
    policy) For details, see Controlling access to keys in the Key Management Service Developer Guide.  Related
    operations:     CreateKey


    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe aws.kms.key
    """

    result = {}
    ret = await hub.exec.boto3.client.kms.list_keys(ctx)

    if not ret["result"]:
        hub.log.debug(f"Could not describe aws.kms.keys {ret['comment']}")
        return {}

    for key in ret["ret"]["Keys"]:
        translated_resource = (
            await hub.tool.aws.kms.conversion_utils.convert_raw_key_to_present(
                ctx, raw_resource=key
            )
        )
        result[translated_resource["resource_id"]] = {
            "aws.kms.key.present": [
                {parameter_key: parameter_value}
                for parameter_key, parameter_value in translated_resource.items()
            ]
        }

    return result
