{"version":3,"file":"static/js/113.d2a2daa6.chunk.js","mappings":"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","sources":["../../core/src/app/titleOfIO.ts","../../core/src/graph/layout.ts","../../core/src/workers/dagre_layout.worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport {titleOfIO} from '../app/titleOfIO';\n\ntype ILayoutConnectionMember = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type ILayoutConnection = {\n  from: ILayoutConnectionMember;\n  to: ILayoutConnectionMember;\n};\n\nexport type IFullPipelineLayout = {\n  width: number;\n  height: number;\n  parent: IParentOpLayout | null;\n  connections: Array<ILayoutConnection>;\n  ops: {\n    [opName: string]: IFullOpLayout;\n  };\n};\n\nexport interface IFullOpLayout {\n  op: ILayout;\n  boundingBox: ILayout;\n  inputs: {\n    [inputName: string]: {\n      layout: ILayout;\n      port: IPoint;\n    };\n  };\n  outputs: {\n    [outputName: string]: {\n      layout: ILayout;\n      port: IPoint;\n    };\n  };\n}\n\ninterface IParentOpLayout extends Omit<IFullOpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: ILayout;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nexport interface ILayout {\n  x: number;\n  y: number;\n  height: number;\n  width: number;\n}\n\nexport interface IPoint {\n  x: number;\n  y: number;\n}\n\nconst MAX_PER_ROW_ENABLED = false;\nconst MAX_PER_ROW = 25;\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport function layoutPipeline(\n  pipelineOps: ILayoutOp[],\n  parentOp?: ILayoutOp,\n): IFullPipelineLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (parentOp) {\n    parentIOPadding = Math.max(parentOp.inputs.length, parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const connections: Array<ILayoutConnection> = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.boundingBox.width,\n      height: layout.boundingBox.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          connections.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: IFullOpLayout} = {};\n  const nodesByOp: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    nodesByOp[opName] = node;\n  });\n\n  if (MAX_PER_ROW_ENABLED) {\n    const nodesInRows: {[key: string]: dagre.Node[]} = {};\n    g.nodes().forEach(function (opName) {\n      const node = g.node(opName);\n      if (!node) {\n        return;\n      }\n      nodesInRows[`${node.y}`] = nodesInRows[`${node.y}`] || [];\n      nodesInRows[`${node.y}`].push(node);\n    });\n\n    // OK! We're going to split the nodes in long (>MAX_PER_ROW) rows into\n    // multiple rows, shift all the subsequent rows down. Note we do this\n    // repeatedly until each row has less than MAX_PER_ROW nodes. There are\n    // a few caveats to this:\n    // - We may end up making the lines betwee nodes and their children\n    //   less direct.\n    // - We may \"compact\" two groups of ops separated by horizontal\n    //   whitespace on the same row into the same block.\n\n    const rows = Object.keys(nodesInRows)\n      .map((a) => Number(a))\n      .sort((a, b) => a - b);\n\n    const firstRow = nodesInRows[`${rows[0]}`];\n    const firstRowCenterX = firstRow\n      ? firstRow.reduce((s, n) => s + n.x + n.width / 2, 0) / firstRow.length\n      : 0;\n\n    for (let ii = 0; ii < rows.length; ii++) {\n      const rowKey = `${rows[ii]}`;\n      const rowNodes = nodesInRows[rowKey];\n\n      const desiredCount = Math.ceil(rowNodes.length / MAX_PER_ROW);\n      if (desiredCount === 1) {\n        continue;\n      }\n\n      for (let r = 0; r < desiredCount; r++) {\n        const newRowNodes = rowNodes.slice(r * MAX_PER_ROW, (r + 1) * MAX_PER_ROW);\n        const maxHeight = Math.max(...newRowNodes.map((n) => n.height)) + OP_BASE_HEIGHT;\n        const totalWidth = newRowNodes.reduce((sum, n) => sum + n.width + OP_BASE_HEIGHT, 0);\n\n        let x = firstRowCenterX - totalWidth / 2;\n\n        // shift the nodes before the split point so they're centered nicely\n        newRowNodes.forEach((n) => {\n          n.x = x;\n          x += n.width + OP_BASE_HEIGHT;\n        });\n\n        // shift the nodes after the split point downwards\n        const shifted = rowNodes.slice((r + 1) * MAX_PER_ROW);\n        shifted.forEach((n) => (n.y += maxHeight));\n\n        // shift all nodes in the graph beneath this row down by\n        // the height of the newly inserted row.\n        const shiftedMaxHeight = Math.max(0, ...shifted.map((n) => n.height)) + OP_BASE_HEIGHT;\n\n        for (let jj = ii + 1; jj < rows.length; jj++) {\n          nodesInRows[`${rows[jj]}`].forEach((n) => (n.y += shiftedMaxHeight));\n        }\n      }\n    }\n    let minX = Number.MAX_SAFE_INTEGER;\n    Object.keys(nodesByOp).forEach((opName) => {\n      const node = nodesByOp[opName];\n      minX = Math.min(minX, node.x - node.width / 2 - marginx);\n    });\n    Object.keys(nodesByOp).forEach((opName) => {\n      const node = nodesByOp[opName];\n      node.x -= minX;\n    });\n  }\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.keys(nodesByOp).forEach((opName) => {\n    const node = nodesByOp[opName];\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = connections.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn) {\n      conn.from.point = points[0];\n      conn.to.point = points[points.length - 1];\n    }\n  });\n\n  const result: IFullPipelineLayout = {\n    ops,\n    connections,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: IFullPipelineLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: IParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    boundingBox: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.boundingBox.y + result.boundingBox.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.boundingBox.x,\n        y: result.boundingBox.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.boundingBox.x + PORT_INSET_X,\n        y: result.boundingBox.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.boundingBox.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.boundingBox.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): IFullOpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for a solid with\n  // input blocks, then the main block, then output blocks (arranged vertically)\n  let accY = root.y;\n\n  const inputsLayouts: {\n    [inputName: string]: {layout: ILayout; port: IPoint};\n  } = {};\n\n  const buildIOSmallLayout = (idx: number, count: number) => {\n    const centeringOffsetX = (OP_WIDTH - IO_MINI_WIDTH * count) / 2;\n    const x = root.x + IO_MINI_WIDTH * idx + centeringOffsetX;\n    return {\n      port: {\n        x: x + PORT_INSET_X,\n        y: accY + PORT_INSET_Y,\n      },\n      layout: {\n        x: x,\n        y: accY,\n        width: IO_MINI_WIDTH,\n        height: IO_HEIGHT,\n      },\n    };\n  };\n\n  const buildIOLayout = () => {\n    const layout: {layout: ILayout; port: IPoint} = {\n      port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n      layout: {\n        x: root.x,\n        y: accY,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n    };\n    accY += IO_HEIGHT;\n    return layout;\n  };\n\n  op.inputs.forEach((input, idx) => {\n    inputsLayouts[input.definition.name] =\n      op.inputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.inputs.length)\n        : buildIOLayout();\n  });\n  if (op.inputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  const opLayout: ILayout = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts: {\n    [outputName: string]: {\n      layout: ILayout;\n      port: IPoint;\n    };\n  } = {};\n\n  op.outputs.forEach((output, idx) => {\n    outputLayouts[output.definition.name] =\n      op.outputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.outputs.length)\n        : buildIOLayout();\n  });\n  if (op.outputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  return {\n    boundingBox: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputsLayouts,\n    outputs: outputLayouts,\n  };\n}\n","/* eslint-disable no-restricted-globals */\n\n/**\n * NOTE: Please avoid adding React as a transitive dependency to this file, as it can break\n * the development workflow. https://github.com/pmmmwh/react-refresh-webpack-plugin/issues/24\n *\n * If you see an error like `$RefreshReg$ is not defined` during development, check the\n * dependencies of this file. If you find that React has been included as a dependency, please\n * try to remove it.\n */\n\nimport {layoutPipeline} from '../graph/layout';\nconst ctx: Worker = self as any;\n\nctx.addEventListener('message', (event) => {\n  const {solids, parentSolid} = event.data;\n  const layout = layoutPipeline(solids, parentSolid);\n  ctx.postMessage(layout);\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [763], function() { return __webpack_require__(19113); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"7bbb5cf7\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t113: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunk_dagster_io_dagit_app\"] = self[\"webpackChunk_dagster_io_dagit_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(763).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["titleOfIO","i","solid","name","definition","OP_BASE_HEIGHT","IO_HEIGHT","PORT_INSET_X","PARENT_INVOCATION_PADDING","flattenIO","arrays","map","forEach","array","item","Object","values","layoutPipeline","pipelineOps","parentOp","g","dagre","graphlib","Graph","parentIOPadding","marginy","marginx","Math","max","inputs","length","outputs","PARENT_DEFINITION_PADDING","setGraph","rankdir","setDefaultEdgeLabel","connections","opNamesPresent","op","layout","layoutOp","x","y","setNode","width","boundingBox","height","input","dependsOn","dep","setEdge","v","w","weight","push","from","point","opName","edgeName","to","ops","nodesByOp","nodes","node","maxWidth","maxHeight","keys","find","edges","e","conn","c","points","edge","result","parent","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","layoutExternalConnections","d","dependedBy","boundingBottom","idx","port","output","layoutParentGraphOp","links","layoutWidth","insetWidth","inset","spacing","baseX","min","yShift","link","shiftDirection","root","accY","inputsLayouts","buildIOSmallLayout","count","centeringOffsetX","buildIOLayout","opLayout","assetNodes","description","outputLayouts","OP_WIDTH","ctx","self","addEventListener","event","data","solids","parentSolid","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","r","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","call","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}